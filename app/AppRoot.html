<!-- Headline Title/Logo -->
<headline>
    <div class="title">
        <span class="side left">MODULAR</span>
        <img src="../static/images/ModularCube.ico" alt="User Icon">
        <span class="side right">CUBE</span>
    </div>
</headline>

<!-- Manual -->
<manual> 
    <!-- Content Summary -->
    <div id="ref_resizable"></div>
    <div id="resizable"> 
        <div id="outline" class="outline">
            <div id="expandable" class="expandable">
                <content-summary></content-summary>
            </div>
            <div class="resizer" mousedownEvent="startResize()"></div>
        </div>
        <div class="version">
            <div class="badge">BETA</div>
        </div> 
    </div>

    <!-- Documentation -->
    <div class="documentation">
        <!-- Introduction -->
        <section>
            <h3 id="introduction">Introduction 📘</h3>
            <section class="sub-section">
                <!-- What is Modular Cube? -->
                <h3 id="introduction">What is Modular Cube?</h3>
                <p>
                    <span class="app-title">Modular Cube</span> is a lightweight frontend framework developed around modern web standards. 
                    It provides a minimal yet expressive system for building dynamic user interfaces, relying solely on native browser features such as <span class="highlight">Custom Elements</span>, <span class="highlight">HTML Templates</span>, <span class="highlight">ES Modules</span>, and the <span class="highlight">Shadow DOM</span>.
                    It does not introduce virtual DOMs, transpilation layers, or non-standard syntax. 
                    Modular Cube allows developers to create user interface components using familiar HTML and JavaScript, while enabling scoped rendering, declarative structure, and encapsulated behaviors without dependencies or build steps.
                </p>
                <!-- Why use Modular Cube? -->
                <h3 id="why-use-it">Why use Modular Cube?</h3>
                <div class="doc-container">
                    <ul class="doc-list">
                        <li>
                            Modular Cube is designed to simplify frontend development while relying solely on modern web standards.
                        </li>
                        <ul>
                            <li><span>🔹</span><p>Built entirely on native browser features such as Custom Elements, Shadow DOM, and ES Modules. No external dependencies or build tools are required.</p></li>
                            <li><span>🔹</span><p>Avoids the overhead of complex runtime engines or compilation steps, making applications faster to load and easier to maintain.</p></li>
                            <li><span>🔹</span><p>Components have isolated structure and styling through Shadow DOM, ensuring clean separation without global conflicts.</p></li>
                            <li><span>🔹</span><p>Developers work directly with HTML, CSS, and JavaScript, enabling them to integrate Modular Cube with existing code or other libraries.</p></li>
                            <li><span>🔹</span><p>By reducing abstraction layers, the framework promotes long-term sustainability and easier debugging.</p></li>
                        </ul>
                    </ul>
                </div>
                <!-- >Key features? -->
                <h3 id="key-features">Key features</h3>
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon">🧬</div>
                        <div class="feature-text">
                            <div class="feature-title">Template Interpolation</div>
                            <p class="feature-desc">Embed JavaScript expressions directly in your HTML using <code>$ {...}</code>. Supported in text content, attributes, class names, and inline styles.</p>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">🧩</div>
                        <div class="feature-text">
                            <div class="feature-title">Conditional templating</div>
                            <p class="feature-desc">Use <code>if</code> directives and its extended forms (e.g. <code>else if</code>, <code>else</code>) to selectively include elements in the DOM based on runtime conditions.</p>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">📋</div>
                        <div class="feature-text">
                            <div class="feature-title">List Rendering</div>
                            <p class="feature-desc">Use <code>forEach</code> directives to generate repeated markup from iterable data structures.</p>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">🖱️</div>
                        <div class="feature-text">
                            <div class="feature-title">Event Binding</div>
                            <p class="feature-desc">Bind native DOM events using a consistent pattern (<code>clickEvent</code>, <code>inputEvent</code>, etc.) to trigger scoped logic without manually registering listeners.</p>
                        </div>
                    </div>
                    <div class="feature-card">
                        <div class="feature-icon">🎯</div>
                        <div class="feature-text">
                            <div class="feature-title">Targeted Updates</div>
                            <p class="feature-desc">DOM updates are scoped and localized, reducing overhead and eliminating re-renders.</p>
                        </div>
                    </div>
                </div>
                <!-- Architecture Based on Web Standards -->
                <h3 id="web-standards">Architecture Based on Web Standards</h3>
                <div class="why-container">
                    <div class="why-item">
                        <div>Custom Elements</div>
                        <p>Encapsulate behavior, state, and rendering logic into self-contained components using JavaScript classes. Each element registers with the browser as a native HTML tag.</p>
                    </div>
                    <div class="why-item">
                        <div>HTML Template Element</div>
                        <p>Templates define reusable blocks of HTML that are parsed but not rendered immediately. They serve as the basis for dynamic rendering and runtime instantiation.</p>
                    </div>
                    <div class="why-item">
                        <div>ES Modules</div>
                        <p>All components and logic are authored as ES modules, allowing clear boundaries, imports, and exports across your codebase using the standard module system.</p>
                    </div>
                    <div class="why-item">
                        <div>Shadow DOM</div>
                        <p>Components use Shadow DOM for true encapsulation of style and structure, isolating internal implementation details from the global DOM tree when needed.</p>
                    </div>
                </div>
                <div class="note-card">
                    <h3>💡 Design Intent</h3>
                    <p> 
                        Modular Cube does not aim to create a new way of building the web, it simply leverages the web as it exists today.
                        Its goal is to <span class="title">empower developers to write UI code that is expressive, explicit, and maintainable,</span> while avoiding the hidden complexity often introduced by large abstractions. 
                        It makes no assumptions about how your application is structured, but provides lightweight conventions to support common frontend needs: data-binding, conditional logic, event handling, and templating.
                        By using only platform features, Modular Cube ensures forward compatibility and encourages a development style that aligns closely with how browsers operate. It is ideal for projects where performance, clarity, and long-term maintainability are key concerns.
                    </p>
                </div>
                <p>
                    These web standards work together to provide a consistent foundation for building components. 
                    They ensure that applications remain compatible with the native browser environment, while keeping the architecture simple, predictable, and easy to extend.
                </p>
            </section>
        </section>
        <!-- Core Concepts -->
        <section>
            <h3 id="core-concepts">Core Concepts 📖</h3>
            <section class="sub-section">
                <!-- Lifecycle -->
                <h3 id="lifecycle">Lifecycle</h3>
                <p>
                    <span class="app-title">Modular Cube</span> lifecycle builds on the native Web Component lifecycle, extending it with custom states for more granular control over initialization and rendering. 
                    This ensures components are predictable, configurable, and modular throughout their lifetime in the DOM.
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>📌 Lifecycle Overview</h4>
                        <li>
                            The Web Component lifecycle methods are as follows:
                        </li>
                        <ul>
                            <li><span>🔹</span><p>constructor()</p></li>
                            <li><span>🔹</span><p>connectedCallback()</p></li>
                            <li><span>🔹</span><p>adoptedCallback()</p></li>
                            <li><span>🔹</span><p>attributeChangedCallback()</p></li>
                            <li><span>🔹</span><p>disconnectedCallback()</p></li>
                        </ul>
                    </ul>
                </div>
                <div class="sub-container flow-chart-container">
                    <div>
                        <span class="highlight">HTMLComponent</span>
                    </div>
                    <div class="flow-chart">
                        <img src="../static/images/HTMLComponentFlowChart.svg" alt="HTMLComponentFlowChart" width="50%">
                    </div>
                </div>
                <h4>📌 Lifecycle Schema (Detailed)</h4>
                <p>
                    This diagram provides a simplified, linear view of the component lifecycle, highlighting the key stages from instantiation to cleanup. 
                    It’s intended as a quick overview to understand the sequence of events and the internal states of a Modular Cube component.
                </p>
                <div class="code-viewer-container">
                    <p><code>(Lifecycle Schema)</code></p>
                    <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                        1. constructor()
                        └── preProcess
                            - Load and validate configuration
                            - Prepare internal state
                            
                        2. connectedCallback()
                        ├── toProcess
                        │    - Component is attached to the DOM
                        │    - Initial checks and setup before rendering
                        │
                        ├── atProcess
                        │    - Resources are loaded
                        │    - Rendering logic executed
                        │    - Component becomes visible
                        │
                        └── inProcess
                            - DOM is fully available
                            - Event listeners attached
                            - Post-render logic executed

                        3. adoptedCallback()
                           - Invoked when the component is moved to a new document

                        4. attributeChangedCallback()
                           - Responds to observed attribute changes
                           - Updates internal state or re-renders if necessary

                        5. disconnectedCallback()
                           - Called when the component is removed from the DOM
                           - Cleanup tasks (removing listeners, releasing resources)
                    </code-viewer>
                </div>
                <!-- constructor -->
                <h4 id="constructor">constructor</h4>
                <p>
                    When a component instance is created, the constructor method is invoked. 
                    In Modular Cube, this immediately calls the <code>preProcess</code> state. At this stage, the component loads and validates its configuration, ensuring all required parameters (such as references to HTML, CSS, or behavior settings) are in place before any further lifecycle steps begin.            
                </p>
                <!-- preProcess -->
                <h4 id="preProcess" class="badge-lifecycle">preProcess</h4>
                <p>
                    When a component’s constructor is invoked, the <code>preProcess</code> state is automatically executed. 
                    During this stage, configuration data is loaded, validated, and prepared before any rendering or attachment to the DOM occurs.
                    The constructor expects a mandatory configuration object with the following structure.
                </p>
                <div class="code-viewer-container">
                    <p><code>(MyComponent.config.json)</code></p>
                    <code-viewer data-tab-id="Config" class="tabcontent" language="json" theme="tomorrow-night-blue">
                        "name": "my-component",   ➝ # Name of the component tag.
                        "descripttion": "",       ➝ # Optional description for documentation or metadata.
                        "files": {
                            "html": {
                                "path": ""        ➝ # Path to the component’s HTML template.
                            },
                            "css": {
                                "path": ""        ➝ # Path to the CSS styles for the component.
                            }
                        },
                        "behavior": {
                            "apendToBody": false, ➝ # Indicates whether the component should be appended to the body tag automatically at load time.
                            "lazyLoading": false, ➝ # Enables deferred loading of components until they are needed.
                            "debug": false        ➝ # Enables debug mode for logging and diagnostics.
                        }
                    </code-viewer>
                </div>
                <div class="code-viewer-container">
                    <p><code>(MyComponent.js)</code></p>
                    <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                        import { HTMLComponent } from '@modular-cube';
                        import config from './MyComponent.config.json' with { type: "json" };

                        // Define a new component by extending the base HTMLComponent class
                        export default class MyComponent extends HTMLComponent {
                            // Called before the component is fully processed
                            // Typically used to load configuration (HTML, CSS, behavior settings, etc.)
                            preProcess() {
                                super.preProcess({ config });
                            }

                            // Called early in the component lifecycle
                            // Can be used to set up initial properties or prepare internal state
                            toProcess() { 
                                // Add early setup logic here
                            }

                            // Called asynchronously during processing
                            // Suitable for tasks like fetching data or performing async operations
                            async atProcess() { 
                                // Add async logic here
                            }

                            // Called after the component’s DOM has been created
                            // Provides access to the shadow DOM for manipulation or event binding
                            inProcess(dom) {
                                // Example: dom.querySelector('.button').addEventListener('click', ...)
                            }
                        }
                    </code-viewer>
                </div>
                <!-- connectedCallback -->
                <h4 id="connectedCallback">connectedCallback</h4>
                <p>
                    The <code>connectedCallback()</code> method is invoked automatically when a custom element is added to the DOM. 
                    This marks the point where the component becomes active and begins its operational lifecycle.
                </p>
                <p>
                    this stage is aligned with the <code>toProcess</code>, <code>atProcess</code>, and <code>inProcess</code> states, which provide a structured sequence for initialization, rendering, and post-render logic.
                    This structured approach ensures that components are consistently initialized and rendered in a predictable order, reducing errors and improving maintainability.
                </p>
                <!-- toProcess -->
                <h4 id="toProcess" class="badge-lifecycle">toProcess</h4>
                <p>
                    When the component is first attached to the DOM, it enters the <code>toProcess</code> state. 
                    This marks the beginning of the active lifecycle, where the component validates prerequisites and prepares resources, but no rendering has yet taken place.
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    // Called early in the component lifecycle
                    // Can be used to set up initial properties or prepare internal state
                    toProcess() { 
                        // Add early setup logic here
                    }
                </code-viewer>
                <!-- atProcess -->
                <h4 id="atProcess" class="badge-lifecycle">atProcess</h4>
                <p>
                    Immediately after prerequisites are resolved within <code>connectedCallback</code>, the <code>atProcess</code> state runs.
                    The component has reached the point where rendering logic is about to be executed. 
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    // Called asynchronously during processing
                    // Suitable for tasks like fetching data or performing async operations
                    async atProcess() { 
                        // Add async logic here
                    }
                </code-viewer>
                <!-- inProcess -->
                <h4 id="inProcess" class="badge-lifecycle">inProcess</h4>
                <p>
                    This state occurs after the component has completed its rendering phase. 
                    The DOM is now fully available for manipulation, and all initial behaviors are active. 
                    At this point, logic that depends on the rendered structure, such as querying the DOM with querySelector, setting focus, or attaching runtime event listeners can be safely executed. 
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    // Called after the component’s DOM has been created
                    // Provides access to the shadow DOM for manipulation or event binding
                    inProcess(dom) {
                        // Example: dom.querySelector('.button').addEventListener('click', ...)
                    }
                </code-viewer>
                <!-- adoptedCallback -->
                <h4 id="adoptedCallback">adoptedCallback</h4>
                <p>
                    The <code>adoptedCallback</code> is a lifecycle method that is called when a custom element is moved from one document to another, such as between iframes or windows.
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    /**
                    * Called when the element is moved to a new document.
                    * For example, between iframes or windows.
                    */
                    adoptedCallback() {
                        // console.log('Custom square element moved to new page.');
                    }
                </code-viewer>
                <!-- attributeChangedCallback -->
                <h4 id="attributeChangedCallback">attributeChangedCallback</h4>
                <p>
                    The <code>attributeChangedCallback</code> is a lifecycle method in Web Components, specifically in the Custom Elements API. 
                    It's used in custom HTML elements to detect when one of the element's observed attributes has changed.
                </p>
                <div class="code-viewer-container">
                    <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                        /**
                        * Called when one of the element's observed attributes changes.
                        *
                        * @param {string} name - The name of the attribute that changed.
                        * @param {string | null} oldValue - The previous value of the attribute.
                        * @param {string | null} newValue - The new value of the attribute.
                        */
                        attributeChangedCallback(name, oldValue, newValue) { }
                    </code-viewer>
                </div>
                <!-- disconnectedCallback -->
                <h4 id="disconnectedCallback">disconnectedCallback</h4>
                <p>
                    The <code>disconnectedCallback</code> is a lifecycle method that’s called when a custom element is removed from the DOM.
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    /**
                    * Called automatically when the component is removed from the DOM.
                    * Use this method to clean up resources such as event listeners,
                    * intervals, observers, or any external references.
                    */
                    disconnectedCallback() { }
                </code-viewer>
                <!-- overview -->
                <h4>📌 Overview</h4>
                <p>
                    The Modular Cube component lifecycle defines how components transition through initialization, configuration, rendering, and cleanup. 
                    It combines the standard Web Component lifecycle methods with custom internal states <code>preProcess</code>, <code>toProcess</code>, <code>atProcess</code>, and <code>inProcess</code> to ensure predictable behavior, structured processing, and safe DOM interactions throughout a component’s existence.
                </p>
                <div class="code-viewer-container">
                    <p><code>(Lifecycle Timeline)</code></p>
                    <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                        ┌────────────────────────────┐
                        │        constructor()       │
                        └──────────────┬─────────────┘
                                       │
                                       ▼
                            [ preProcess state ]
                            - Load configuration
                            - Validate settings
                            - Initialize internal state
                                       │
                                       ▼
                        ┌────────────────────────────┐
                        │     connectedCallback()    │
                        └──────────────┬─────────────┘
                                       │
                                       ▼               
                               [ toProcess state ]   
                               - Attached to DOM      
                               - Pre-render checks      
                                       │
                                       ▼
                               [ atProcess state ]
                               - Resources loaded
                               - Rendering logic executed
                               - Component becomes visible
                                       │
                                       ▼
                               [ inProcess state ]
                               - DOM ready for manipulation
                               - Events bound, behaviors active
                                       │
                                       └───────────────────────┐
                         ┌────────────────────────────┐        │
                         │    adoptedCallback()       │ ◄──────┘
                         │ (when moved to new doc)    │        │
                         └────────────────────────────┘        │        
                                                               │
                         ┌────────────────────────────┐        │
                         │ attributeChangedCallback() │ ◄──────┘
                         │ (reactive updates on attrs)│        │ 
                         └────────────────────────────┘        │
                                       ┌───────────────────────┘
                                       │
                                       ▼
                        ┌─────────────────────────────┐
                        │   disconnectedCallback()    │
                        │(cleanup + resource release) │
                        └─────────────────────────────┘
                    </code-viewer>
                </div>
                <p>
                    The component lifecycle in Modular Cube unifies the standard Web Component callbacks with additional custom states. This approach establishes a predictable sequence in which configuration is validated, resources are prepared, rendering takes place, and post-render behavior becomes available.
                    By following this structured progression, components remain consistent, modular, and easier to maintain, regardless of complexity or use case.
                </p>
            </section>
        </section>
        <!-- Project Structure -->
        <section>
            <h3 id="project-structure">Project Structure 🗃️</h3>
            <section class="sub-section">
                <!-- Overall Folder Organization -->
                <h3 id="overall-folder-organization">Overall Folder Organization</h3>
                <div class="doc-container">
                    <ul class="doc-list">
                        <li>A project consists of a set of files and folders that can be organized in a consistent structure.</li>
                        <ul>
                            <li><span>🔹</span><p>Configuration files, initialization logic, and the main entry point reside at the root level.</p></li>
                            <li><span>🔹</span><p>UI components are grouped within the <code>app/</code> directory.</p></li>
                            <li><span>🔹</span><p>Supporting folders such as <code>static/</code>, <code>modules/</code>, and <code>services/</code> are used to manage assets, reusable functionality, and core application logic.</p></li>
                        </ul>
                    </ul>
                </div>
                <p>
                    This organization establishes distinct responsibilities for different parts of the project, making it easier to navigate, maintain, and extend over time.
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    my-project/
                    │
                    ├── app.config.json      # Application Configuration
                    ├── init.js              # Component Initialization
                    ├── index.html           # Entry Point
                    ├── .gitignore           
                    │
                    └── app/                 # All Components
                    │   ├── AppRoot.config.json
                    │   ├── AppRoot.css
                    │   ├── AppRoot.html
                    │   ├── AppRoot.js
                    │   │
                    │   ├── collapse-panel/
                    │   │   ├── CollapsePanel.config.json
                    │   │   ├── CollapsePanel.html
                    │   │   ├── CollapsePanel.css
                    │   │   └── CollapsePanel.js
                    │   │
                    │   ├── tab-panel/
                    │   │   ├── TabPanel.config.json
                    │   │   ├── TabPanel.html
                    │   │   ├── TabPanel.css
                    │   │   └── TabPanel.js
                    │   │
                    │   └── ...
                    │
                    ├── modules/             # Reusable Utility Modules
                    │   ├── dom-utils.js
                    │   └── string-format.js
                    │
                    └── services/            # Application Services
                    │   ├── api.service.js
                    │   ├── state.service.js
                    │   └── auth.service.js
                    │
                    └── static/              # Static Assets (images, fonts, icons, etc.)
                        ├── logo.ico
                        └── style-guide.pdf
                </code-viewer>
                <!-- Application Configuration -->
                <h3 id="application-configuration">Application Configuration <span class="badge">(app.config.json)</span></h3>
                <p>
                    To make a component available to the application, it must be registered in the global application configuration file: <code>app.config.json</code>.
                    This setup allows the framework to dynamically load and define the components at runtime.
                </p>
                <p>
                    The application configuration file <code>app.config.json</code> contains a root object named <code>modularCube</code>, which describes both the <code>application</code> entry point and the <code>components</code> that will be registered.
                </p>
                <code-viewer data-tab-id="Config" class="tabcontent" language="json" theme="tomorrow-night-blue">
                    {
                        "modularCube": {
                            "application": {
                                "name": "app-root",       ➝ # Name of the component tag.
                                "descripttion": "",       ➝ # Optional description for documentation or metadata.
                                "files": {
                                    "html": {
                                        "path": ""        ➝ # Path to the component’s HTML template.
                                    },
                                    "css": {
                                        "path": ""        ➝ # Path to the CSS styles for the component.
                                    }
                                },
                                "behavior": {
                                    "apendToBody": false, ➝ # Indicates whether the component should be appended to the body tag automatically at load time.
                                    "lazyLoading": false, ➝ # Enables deferred loading of components until they are needed.
                                    "debug": false        ➝ # Enables debug mode for logging and diagnostics.
                                }
                            },
                            "components": [
                                # tag: The custom element tag name used to register the component.Must follow kebab-case format.
                                # path: The path to the JavaScript module that defines the component.
                                {
                                    "tag": "app-root",
                                    "path": "./app/AppRoot.js"
                                },
                                {
                                    "tag": "content-summary",
                                    "path": "./app/content-summary/ContentSummary.js"
                                },
                                {
                                    "tag": "collapse-panel",
                                    "path": "./app/collapse-panel/CollapsePanel.js"
                                },
                                {
                                    "tag": "tab-panel",
                                    "path": "./app/tab-panel/TabPanel.js"
                                },
                                {
                                    "tag": "code-viewer",
                                    "path": "./app/code-viewer/CodeViewer.js"
                                }
                            ]
                        }
                    }
                </code-viewer>
                <div class="note-card">
                    <h3>💡 Notes</h3>
                    <p>The <code>application</code> attribute is optional. Its purpose is to define the root application container.</p>
                    <ul>
                        <li>
                            When the application is initialized using <code>Dom.init()</code>, it first looks at the <code>components</code> attribute list.
                            If an entry component (for instance, <code>app-root</code>) is defined there, it will be instantiated as the root.
                        </li>
                        <li>
                            If no entry component is found in the <code>components</code> attribute list, <code>Dom.init()</code> will then check whether an <code>application</code> attribute exists.
                            If present, the <code>application</code> will be used to define and initialize the root container.
                        </li>
                    </ul>
                </div>
                <!-- Component Initialization -->
                <h3 id="component-initialization">Component Initialization <span class="badge">(init.js)</span></h3>
                <p>
                    The <code>init.js</code> file is the bootstrap script. 
                    Its job is to initialize your application, load the configuration, and register components before rendering.
                    After defining and registering all components, the application must initialize the system using the <code>Dom.init()</code> method. 
                </p>
                <code-viewer data-tab-id="JavaScript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    /* Default initialization */
                    import { Dom } from '@modular-cube';

                    await Dom.init(() => {
                        // App initialized after DOM is ready
                    });
                </code-viewer>
                <code-viewer data-tab-id="JavaScript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    /* Inline component registration */
                    import { Dom } from '@modular-cube';

                    await Dom.init(([
                        { tag: 'my-component', type: MyComponent }
                    ]) => {
                        // App initialized after DOM is ready
                    });
                </code-viewer>
                <p>
                    By default, <code>app.config.json</code> should be placed at the same folder level as <code>init.js</code>. 
                    If no parameter is provided, the initializer will look for it automatically.
                    If the configuration file is stored elsewhere, you can provide its path explicitly:
                </p>
                <code-viewer data-tab-id="JavaScript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    /* Initialization with a configuration file */
                    await Dom.init(('./configs/app.config.json') => {
                        // App initialized after DOM is ready
                    });
                </code-viewer>
                <!-- Entry Point -->
                <h3 id="entry-point">Entry Point <span class="badge">(index.html)</span></h3>
                <p>
                    The <code>index.html</code> is the root document of your project. 
                    It loads the initialization script and acts as the starting point for rendering UI components.
                    To ensure components are initialized properly at application startup, the <code>init.js</code> file must be imported in the main HTML file.
                </p>
                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8" />
                        <title>Modular App</title>
                        <!--
                            Import map for the Modular Cube library. 
                            Provides the base HTMLComponent class and utility functions required by all components. 
                        -->
                        <script type="importmap">
                            {
                                "imports": {
                                    "@modular-cube": "https://cdn.jsdelivr.net/gh/mxi-git-repo/modular-cube/main.js"
                                }
                            }
                        </script>
                        <!-- 
                            Import the initialization script. 
                            This ensures that application configuration and components are loaded and registered when the project starts. 
                        -->
                        <script type="module" src="./init.js"></script>
                    </head>
                    <body>
                        <!-- 
                            Application content is placed here. 
                            The root component can be declared inside <body> to bootstrap the UI. 
                        -->
                    </body>
                    </html>
                </code-viewer>
                <p>
                    The import map, initialization script, and root component provide the foundation of the application. 
                    The <code>index.html</code> file serves as the starting point where these elements are brought together to initialize and render the user interface.
                </p>
            </section>
        </section>
        <!-- Component Setup -->
        <section>
            <h3 id="component-setup">Component Setup 🗂️</h3>
            <section class="sub-section">
                <!-- Component File Structure -->
                <h3 id="component-file-structure">Component File Structure</h3>
                <p>
                    Each component in Modular Cube is encapsulated using the Shadow DOM to ensure scoped styles and isolated behavior. 
                    By convention, a component can be composed of four main files:
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    MyComponent/
                    ├── MyComponent.config.json # Declares the component’s metadata, file paths, and behavior options.
                    ├── MyComponent.css         # Provides scoped styling applied only to the component instance.
                    ├── MyComponent.html        # Defines the component’s structure and static markup.
                    └── MyComponent.js          # Implements the component’s behavior and lifecycle.
                </code-viewer>
                <p>The framework allows you to keep <code>HTML</code> and <code>CSS</code> in separate files for clarity.</p>
                <!-- Component Files -->
                <h3 id="component-files">Component Files</h3>
                <div class="doc-container">
                    <ul class="doc-list">
                        <li>
                            A Modular Cube component is built from a small set of well-defined files, each responsible for a specific concern. 
                            This separation of structure, styling, configuration, and behavior promotes clarity and maintainability. 
                            By convention, every component consists of four files:
                        </li>
                        <ul>
                            <li><span>🔹</span><p>A configuration file <code>(.config.json)</code> to declare metadata, file paths, and runtime options.</p></li>
                            <li><span>🔹</span><p>A CSS stylesheet <code>(.css)</code> to provide encapsulated styles.</p></li>
                            <li><span>🔹</span><p>An HTML template <code>(.html)</code> to define the component’s structure.</p></li>
                            <li><span>🔹</span><p>A JavaScript module <code>(.js)</code> to implement the component’s logic and lifecycle.</p></li>
                        </ul>
                    </ul>
                    <p>Together, these files ensure that each component remains self-contained, easy to reason about, and reusable across different parts of the application.</p>
                </div>
                <!-- Configuration -->
                <h4 id="configuration">Configuration <span class="badge">(.config.json)</span></h4>
                <p>
                    The configuration file defines metadata, file references, and runtime behaviors for the component. 
                    It specifies the paths to the associated <code>HTML</code> and <code>CSS</code> files, along with options such as <code>appendToBody</code>, <code>lazyLoading</code>, and <code>debug</code>.
                </p>
                <code-viewer data-tab-id="Config" class="tabcontent" language="json" theme="tomorrow-night-blue">
                    {
                        "name": "my-component",   ➝ # Name of the component tag.
                        "descripttion": "",       ➝ # Optional description for documentation or metadata.
                        "files": {
                            "html": {
                                "path": ""        ➝ # Path to the component’s HTML template.
                            },
                            "css": {
                                "path": ""        ➝ # Path to the CSS styles for the component.
                            }
                        },
                        "behavior": {
                            "apendToBody": false, ➝ # Indicates whether the component should be appended to the body tag automatically at load time.
                            "lazyLoading": false, ➝ # Enables deferred loading of components until they are needed.
                            "debug": false        ➝ # Enables debug mode for logging and diagnostics.
                        }
                    }
                </code-viewer>
                <!-- Styling -->
                <h4 id="styling">Styling <span class="badge">(.css)</span></h4>
                <p>
                    The stylesheet provides styles scoped to the component through the Shadow DOM. 
                    This ensures that styles remain encapsulated and do not leak into the global document. 
                    Keeping styles in a separate file helps maintain a clean separation between structure, logic, and presentation.
                </p>
                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                    /* Styles applied to the component’s host element (Shadow DOM root) */
                    :host {
                        display: flex;              /* Use flexbox for layout */
                        flex-direction: column;     /* Arrange child elements vertically */
                        width: 100%;                /* Expand to full width of parent */
                        height: 100%;               /* Expand to full height of parent */
                        gap: 0.5rem;
                    }

                    /* Example of a styled internal container */
                    .container {
                        border: 1px solid #ccc;             
                        padding: 1rem;
                    }

                    /* Example of a header element */
                    .header {
                        font-size: 1.25rem;       
                        font-weight: bold;      
                    }

                    /* Example of a content section */
                    .content {
                        flex: 1;                    
                        line-height: 1.5;           
                    }

                    /* Example of a footer element */
                    .footer {
                        font-size: 0.875rem; 
                        color: #666;  
                    }
                </code-viewer>
                <!-- Template -->
                <h4 id="template">Template <span class="badge">(.html)</span></h4>
                <p>
                    The HTML template defines the component’s structure and static markup. 
                    It serves as the foundation of the component’s UI, which is later combined with the stylesheet and logic during initialization. 
                    Using an external template file improves readability and keeps layout concerns separate from logic.
                </p>
                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                    <!-- Root component template -->
                    <div class="container">
                        
                        <!-- Header section -->
                        <div class="header">
                            Component Header
                        </div>

                        <!-- Main content area -->
                        <div class="content">
                            <p>
                                This is an example content block inside the component.  
                                It can contain text, links, or other nested elements.
                            </p>
                        </div>

                        <!-- Footer section -->
                        <div class="footer">
                            Footer information or actions
                        </div>
                    </div>
                </code-viewer>
                <!-- MyComponent -->
                <h4 id="my-component">MyComponent <span class="badge">(.js)</span></h4>
                <p>
                    The JavaScript file implements the component’s logic, lifecycle, and behaviors. 
                    It loads the configuration, processes the referenced <code>HTML</code> and <code>CSS</code> files (via <code>preProcess()</code>), and manages dynamic interactions. 
                    This file is responsible for defining how the component behaves.
                </p>
                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                    import { HTMLComponent } from '@modular-cube';
                    import config from './MyComponent.config.json' with { type: "json" };

                    // Define a new component by extending the base HTMLComponent class
                    export default class MyComponent extends HTMLComponent {

                        // Called before the component is fully processed
                        // Typically used to load configuration (HTML, CSS, behavior settings, etc.)
                        preProcess() {
                            super.preProcess({ config });
                        }

                        // Called early in the component lifecycle
                        // Can be used to set up initial properties or prepare internal state
                        toProcess() { 
                            // Add early setup logic here
                        }

                        // Called asynchronously during processing
                        // Suitable for tasks like fetching data or performing async operations
                        async atProcess() { 
                            // Add async logic here
                        }

                        // Called after the component’s DOM has been created
                        // Provides access to the shadow DOM for manipulation or event binding
                        inProcess(dom) {
                            // Example: dom.querySelector('.button').addEventListener('click', ...)
                        }
                    }
                </code-viewer>
                <p>
                    Each of these files plays a specific role in defining a component. 
                    The <code>configuration</code> file describes its metadata and behavior, the <code>CSS</code> handles encapsulated styling, the <code>HTML</code> defines its structure, and the <code>JavaScript</code> manages its logic and lifecycle. 
                    Together, they provide a clear and modular approach to building self-contained, maintainable components.
                </p>
            </section>
        </section>
        <!-- Using Components -->
        <section>
            <h3 id="using-components">Using Components 🧩</h3>
            <!-- HTML -->
            <h3 id="work-with-html">HTML</h3>
            <section class="sub-section">
                <!-- HTML Directives -->
                <h3 id="html-directives">Directives</h3>
                <p>
                    HTML directives provide a declarative way to extend component templates by using attributes. 
                    They make components easier to read and maintain by clearly expressing intent in the markup. 
                    Directives support dynamic binding, allowing variables, expressions, or configuration values to be injected directly into the template. They can also control behavior, such as managing conditional rendering, iterating over collections, or binding events to elements.
                </p>
                <!-- HTML variable -->
                <h3 id="html-variable">variable</h3>
                <p>
                    The template interpolation enables the embedding of JavaScript expressions directly within HTML content, using the <code>$ {...}</code> syntax. 
                    This mechanism allows dynamic rendering of component state and computed values inline within native HTML templates.
                    Interpolation is resolved at render time and evaluated within the current data context (typically the component instance <code>this</code> or the shadow root scope).
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Constraints and Best Practices
                        </h4>
                        <ul>
                            <li><span>🔹</span><p>Only valid JavaScript expressions are allowed. These must reference properties or methods available in the current scope.</p></li>
                            <li><span>🔹</span><p>Functions used within expressions must be side-effect-free and return a value.</p></li>
                            <li><span>🔹</span><p>Expressions should remain simple and easy to read. Complex logic or deeply nested expressions should be avoided.</p></li>
                        </ul>
                    </ul>
                </div>
                <div class="note-card-info">
                    <h3>🔍 Syntax & Supported Contexts</h3>
                    <p class="title">Expressions are enclosed in <code>$ { expression }</code>:</p>
                    <ul> 
                        <li>Text content within HTML elements.</li> 
                        <li>Attribute values (<code>class</code>, <code>title</code>, <code>placeholder</code>, ... ).</li> 
                        <li>Class attribute for dynamic class names.</li> 
                        <li>Inline styles via the style attribute.</li>
                    </ul>
                </div>
                <p>The following examples show proper uses of interpolation for binding values in different parts of the DOM.</p>
                <collapse-panel title="Interpolation in HTML">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        word = "world";
                                        title = "Variable Interpolation";
                                        color = "red";

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Text content interpolation -->
                                    <p>Hello, ${this.word}!</p>

                                    <!-- Attribute binding -->
                                    <img alt="${this.title}">

                                    <!-- Conditional class binding -->
                                    <div class="card-${this.color}">...</div>

                                    <!-- Inline style binding -->
                                    <span style="color: '${this.color}';">Colored Text</span>
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */

                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                     <p>Hello, world!</p>

                                     <img title="Variable Interpolation">

                                     <div class="card-red">...</div>

                                     <span style="color: 'red'">Colored Text</span>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <p>
                    The <code>&lt;param value=""&gt;</code> feature allows direct injection of parameter values into HTML content by specifying dynamic values through component parameters. 
                    This mechanism functions similarly to template interpolation but is limited to inserting parameterized values into designated HTML attributes or content areas.
                    Values assigned via <code>&lt;param value=""&gt;</code> are evaluated against the component’s parameter scope during the initial render 
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Constraints and Best Practices
                        </h4>
                        <ul>
                            <li><span>🔹</span><p>Each <code>&lt;param&gt;</code> element with a <code>value</code> attribute is replaced with the current value of the corresponding parameter during the initial render.</p></li>
                            <li><span>🔹</span><p>Parameter values are evaluated from the component’s declared parameter scope.</p></li>
                            <li><span>🔹</span><p>Parameter values injected via <param> should be serializable and renderable as strings suitable for direct HTML insertion.</p></li>
                            <li><span>🔹</span><p>Complex or computed values should be resolved before assignment to parameters.</p></li>
                            <li><span>🔹</span><p>The <code>&lt;param&gt;</code> tag is a placeholder element and does not produce standalone DOM elements after rendering; it is replaced entirely by the parameter’s value.</p></li>
                        </ul>
                    </ul>
                </div>
                <collapse-panel title="Rendering Content Using param">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        paramValue = "Example Value";

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div>
                                        <param value="${this.paramValue}">
                                    </div>
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div>
                                        Example Value
                                    </div>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <p>
                    The template interpolation facilitates embedding dynamic data into HTML templates using <code>$ {...}</code> expressions. 
                    Evaluation occurs initially during render and later only when explicitly requested, enabling predictable and efficient updates without automatic reactive tracking.
                </p>
                <p>
                    The <code>&lt;param value=""&gt;</code> feature provides a mechanism for injecting component parameter values directly into HTML content. 
                    It complements template interpolation by enabling straightforward pass-through of parameter values, evaluated initially at render and updated explicitly on demand. 
                    This feature maintains predictable rendering behavior and minimizes unnecessary DOM manipulations by leveraging explicit update triggers.
                </p>
                <!-- HTML condition -->
                <h3 id="html-condition"><span>if</span> / <span>else if</span> / <span>else</span></h3>
                <p>
                    The <span class="highlight">if</span> directive provides conditional rendering in HTML templates using declarative expressions. 
                    It enables developers to control whether a given element and its children should be rendered based on the evaluation of a boolean condition.
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Feature supports
                        </h4>
                        <ul>
                            <li><span>🔹</span><p>These directives follow a familiar control-flow structure. They are evaluated in order, and only the first matching condition will be rendered.</p></li>
                            <li><span>🔹</span><p><code>else if</code> must directly follow a <code>if</code> or another <code>else if</code>.</p></li>
                            <li><span>🔹</span><p>Only one <code>else</code> block is allowed per <code>if</code> chain.</p></li>
                        </ul>
                    </ul>
                </div>
                <collapse-panel title="Conditional Rendering with if">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        isValid = true;
                                        isNotValid = false;
                                        color = "blue";

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Example 01 – Multiple Independent *if Conditions (No Fallback) -->
                                    <div id="example_01">
                                        <!-- Rendered if color is "blue" -->
                                        <div if="${this.color === 'blue'}">test1</div>

                                        <!-- Rendered if color is "red" -->
                                        <div if="${this.color === 'red'}">test2</div>

                                        <!-- Rendered if color is "yellow" -->
                                        <div if="${this.color === 'yellow'}">test3</div>
                                    </div>

                                    <!-- Example 02 – Nested Independent *if Blocks -->
                                    <div id="example_02">
                                        <!-- Outer condition: only evaluated if color is "blue" -->
                                        <div if="${this.color === 'blue'}">

                                            <!-- Rendered if color is "blue" AND isValid is true -->
                                            <div if="${this.isValid}">test4</div>

                                            <!-- Rendered if color is "blue" AND isNotValid is true -->
                                            <!-- These are independent checks — both can render if true -->
                                            <div if="${this.isNotValid}">test5</div>
                                        </div>
                                    </div>
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div id="example_01">
                                        <div>test1</div>
                                    </div>

                                    <div id="example_02">
                                        <div>
                                            <div>test4</div>
                                        </div>
                                    </div>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <collapse-panel title="if Statement with an else Clause">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        isValid = true;
                                        isNotValid = false;
                                        color = "blue";

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>

                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Example 03 – Multiple *if conditions with a final *else -->
                                    <div id="example_03">
                                        <!-- Rendered if color is "blue" -->
                                        <div if="${this.color === 'blue'}">test1</div>

                                        <!-- Rendered if color is "red" and previous condition was false -->
                                        <div if="${this.color === 'red'}">test2</div>

                                        <!-- Rendered if color is "yellow" and previous conditions were false -->
                                        <div if="${this.color === 'yellow'}">test3</div>

                                        <!-- Rendered only if none of the above conditions match -->
                                        <div else>test4</div>
                                    </div>

                                    <!-- Example 04 – Nested *if blocks -->
                                    <div id="example_04">
                                        <!-- Outer condition: rendered only if color is "blue" -->
                                        <div if="${this.color === 'blue'}">
                                            <!-- Rendered if color is "blue" AND isValid is true -->
                                            <div if="${this.isValid}">test5</div>

                                            <!-- Rendered if color is "blue" AND isNotValid is true -->
                                            <!-- Note: these are separate sibling conditions and are not mutually exclusive -->
                                            <div if="${this.isNotValid}">test6</div>
                                        </div>

                                        <!-- Rendered only if color is NOT "blue" -->
                                        <div else>test7</div>
                                    </div>
                                </code-viewer>

                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div id="example_03">
                                        <div>test1</div>
                                        <div>test4</div>
                                    </div>

                                    <div id="example_04">
                                        <div>
                                            <div>test5</div>
                                        </div>
                                    </div>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <collapse-panel title="if, else if, and else Chain">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        isValid = true;
                                        isNotValid = false;
                                        color = "blue";

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Example 05 – Full *if → *elseIf → *else Chain -->
                                    <div id="example_05">
                                        <!-- Rendered if color is "purple" -->
                                        <div if="${this.color === 'purple'}">test1</div>

                                        <!-- Rendered if the previous condition was false AND color is "red" -->
                                        <div elseIf="${this.color === 'red'}">test2</div>
                                        
                                        <!-- Rendered if previous conditions were false AND color is "blue" -->
                                        <div elseIf="${this.color === 'blue'}">test3</div>

                                        <!-- Rendered only if none of the above conditions match -->
                                        <div else>test4</div>
                                    </div>
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div id="example_05">
                                        <div>test3</div>
                                    </div>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <div class="note-card">
                    <h3>💡 Notes</h3>
                    <p>
                        In JavaScript, you can absolutely use <code>if</code>, <code>else if</code>, <code>else if</code> without a final <code>else</code>. 
                        The else block is completely optional.
                    </p>
                    <ul>
                        <li>✅ You can have just <code>if</code></li>
                        <li>✅ You can have <code>if</code>...<code>else</code></li>
                        <li>✅ You can have <code>if</code>...<code>else if</code>...<code>else</code></li>
                        <li>✅ You can have <code>if</code>...<code>else if</code>...<code>else if</code> (with or without <code>else</code>)</li>
                    </ul>
                </div>
                <p>
                    The <span class="highlight">if</span> directive allows declarative, structured control of what elements are rendered based on logical conditions. Support for <code>else if</code>, <code>else</code>, and nested conditionals provides flexibility while maintaining clear and predictable rendering behavior. 
                    The use of native HTML syntax and controlled evaluation reinforces clarity, performance, and consistency with modern web development practices.
                </p>
                <!-- HTML loop -->
                <h3 id="html-loop">forEach</h3>
                <p>
                    The <span class="highlight">forEach</span> directive in enables declarative iteration over collections within HTML templates. 
                    It renders a repeated structure for each item in a given array or iterable, following a clear and scoped expression pattern. 
                    This approach brings structured, readable list rendering to markup using standard JavaScript expression syntax.
                    This directive is designed to integrate seamlessly with the component's data context and maintain clarity in both simple and nested list structures.
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Feature supports
                        </h4>
                        <ul>
                            <li><span>🔹</span><p><code>forEach</code> directive must use the syntax: <code>let item in items</code>.</p></li>
                            <li><span>🔹</span><p>You can loop inline using array literals: <code>let item of [1, 2, 3]</code>.</p></li>
                            <li><span>🔹</span><p>The value after <code>in</code> must be an array or iterable.</p></li>
                            <li><span>🔹</span><p>You cannot use multiple structural directives <code>(if, forEach, etc.)</code> on the same element.</p></li>
                            <li><span>🔹</span><p>You can nest <code>forEach</code> with <code>*if</code> or another <code>forEach</code> block.</p></li>
                        </ul>
                    </ul>
                </div>
                <div class="note-card-info">
                    <h3>🔍 Syntax & Supported Contexts</h3>
                    <p>
                        &lt;<code class="title">div</code> forEach="$ {item} in $ {this.items}"&gt; <br>
                            <span style="padding-left: 12px;">Content using <code class="title">item</code></span><br>
                        &lt;<code class="title">/div</code>&gt;
                    </p>
                    <ul> 
                        <li><code>$ {item}</code> defines the loop variable for each iteration.</li> 
                        <li><code>$ {this.items}</code> must evaluate to an array or iterable object in the current context.</li> 
                        <li>The loop variable is scoped to its instance within the repeated block.</li>
                    </ul>
                </div>
                <collapse-panel title="Looping with forEach">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        items = [1, 2, 3];

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!--
                                    <div forEach="${item} in ${this.items}">
                                        <div id="${item}">
                                            item: <param value="${item}">
                                        </div>
                                    </div>
                                    -->
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div>
                                        <div id="1"> item: 1 </div>
                                        <div id="2"> item: 2 </div>
                                        <div id="3"> item: 3 </div>
                                    </div>
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <p>
                    The <span class="highlight">forEach</span> directive offers a concise and powerful way to generate HTML content dynamically based on collection data. 
                    With native expression support and clear scope handling, it supports structured iteration at any depth and promotes maintainable template design. 
                    Repeated content is easy to define and aligns with modern rendering practices through direct integration with JavaScript evaluation and native web capabilities.
                </p>
                <!-- Events -->
                <h3 id="html-events">Events</h3>
                <p>
                    HTML directives support binding JavaScript event handlers directly within your markup using a simple and consistent syntax. 
                    It handle DOM events like <code>click</code>, <code>input</code>, <code>keydown</code>, <code>mouseenter</code>, and more.
                    These bindings follow standard JavaScript event behavior but are declared directly in the template, no need for addEventListener or inline onclick attributes.
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Important Rules
                        </h4>
                        <ul>
                            <li><span>🔹</span><p>Use the format: <code><span class="placeholder">placeholder</span>Event="this.functionCall(...)"</code>.</p></li>
                            <li><span>🔹</span><p>The event name must be lowercase and match a standard DOM event (e.g. <code>click</code>, <code>input</code>, <code>keydown</code>).</p></li>
                            <li><span>🔹</span><p>You must append <code>Event</code> to the event name: <code>clickEvent</code>, <code>inputEvent</code>, <code>keydownEvent</code>, etc.</p></li>
                            <li><span>🔹</span><p>The value must be a valid JavaScript function call (with or without arguments).</p></li>
                            <li><span>🔹</span><p>The <code>$event</code> object can be passed to access native event data.</p></li>
                        </ul>
                    </ul>
                </div>
                <collapse-panel title="Event Bindings">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        total = 0;

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }

                                        addNumber(value) {
                                            this.total += value;
                                            console.log(this.total);
                                        }

                                        subtractNumber(value) {
                                            this.total -= value;
                                            console.log(this.total);
                                        }

                                        reset() {
                                            this.total = 0;
                                            console.log(this.total);
                                        }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <div clickEvent="addNumber(5)"></div>
                                    <div clickEvent="subtractNumber(3)"></div>
                                    <div resizeEvent="reset()"></div>
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Console output -->
                                    <!-- 5 -->
                                    <!-- 2 -->
                                    <!-- 0 -->
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <div class="note-card">
                    <h3>💡 Notes</h3>
                    <ul>
                        <li>✅ You can bind any number of events to an element.</li>
                        <li>✅ Any function accessible in the component’s scope can be used.</li>
                        <li>✅ <code>$event</code> gives you access to native event details (like target, key, etc.).</li>
                        <li>❌ Do not use <code>onClick</code>, <code>onInput</code>, etc. — use <code>clickEvent</code>, <code>inputEvent</code>, etc. instead.</li>
                        <li>✅ Event bindings can be combined with <code>if</code> / <code>else if</code> / <code>else</code> and <code>forEach</code> for dynamic UI behavior.</li>
                    </ul>
                </div>
            </section>
            <!-- CSS -->
            <h3 id="work-with-css">CSS</h3>
            <section class="sub-section">
                <!-- CSS Directives -->
                <h3 id="css-directives">Directives</h3>
                <p>
                    CSS directives provide a way to make component styling more flexible and maintainable by supporting variable substitution and scoped customization. 
                    They enable styles to adapt dynamically at runtime without breaking encapsulation.
                </p>
                <!-- CSS variable -->
                <h3 id="css-variable">variable</h3>
                <p>
                    Template interpolation enables the embedding of JavaScript expressions directly within CSS content, using the <code>$ {...}</code> syntax.                    
                    This works similarly to HTML template interpolation, allowing you to bind JavaScript properties or return values directly into your styles at render time. 
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Important Rules
                        </h4>
                        <ul>
                            <li><span>🔹</span><p>Expressions must be valid JavaScript and scoped to the current component (<code>this.property</code> or <code>this.method()</code>).</p></li>
                            <li><span>🔹</span><p>Only values that result in a valid CSS value are allowed (colors, units, keywords).</p></li>
                            <li><span>🔹</span><p>Function calls must return a value and must be pure (no side effects).</p></li>
                            <li><span>🔹</span><p>You can interpolate in inline styles, style blocks, or custom properties (e.g., <code>--my-color: $ {this.color}</code>).</p></li>
                            <li><span>🔹</span><p>Do not use interpolation inside CSS selectors or media queries, only in property values.</p></li>
                            <li><span>🔹</span><p>Keep expressions simple and readable. Avoid chaining or complex logic inside styles.</p></li>
                        </ul>
                    </ul>
                </div>
                <collapse-panel title="Interpolation in CSS">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    export default class MyComponent extends HTMLComponent {
                                        borderRadius = "8px";
                                        cardBackground = "#fafafa"

                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Document Content -->
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    :host {
                                        --component-radius: ${this.borderRadius};
                                    }

                                    .card {
                                        border: 1px solid #ccc;
                                        border-radius: var(--component-radius);
                                        padding: 1rem;
                                        background: ${this.cardBackground};
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    :host {
                                        --component-radius: 8px;
                                    }

                                    .card {
                                        border: 1px solid #ccc;
                                        border-radius: var(--component-radius);
                                        padding: 1rem;
                                        background: #fafafa;
                                    }
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <div class="note-card" style="margin-bottom: 12px;">
                    <h3>💡 Notes</h3>
                    <ul>
                        <li>CSS interpolation works at render time, changes to reactive properties will automatically reflect in styles.</li>
                        <li>This feature is framework-specific and not standard browser behavior. It is optimized for Shadow DOM scoping and dynamic styling needs.</li>
                        <li>Only string-compatible values will work, no objects, arrays, or DOM references.</li>
                        <li>You can use component-scoped CSS variables for theming or design tokens, <code>--theme-accent: $ {this.accentColor}</code>.</li>
                    </ul>
                </div>
            </section>
            <!-- JavaScript -->
            <h3 id="work-with-js">JavaScript</h3>
            <section class="sub-section">
                <!-- Observable -->
                <h3 id="observable">Observable</h3>
                <p>
                    The framework includes a lightweight <span class="highlight">Observable</span> utility for managing event-based communication between components or logic blocks.
                    This pattern allows you to decouple parts of your application by subscribing to and publishing named events, similar to a pub/sub model.
                </p>
                <div class="doc-container">
                    <ul class="doc-list">
                        <h4>
                            📌 Core Concepts
                        </h4>
                        <ul>
                            <li><span>🔹</span><p><code>subscribe(name, subscriber)</code>: Register a function to run when a named event is published.</p></li>
                            <li><span>🔹</span><code>unsubscribe(name)</code>: Remove a previously registered event handler.</li>
                            <li><span>🔹</span><p><code>publish(name, payload)</code>: Trigger all subscriber callbacks for the given event name, passing in an optional payload.</p></li>
                            <li><span>🔹</span><p>Each event supports a single active subscriber — subsequent calls with the same name will replace previous ones.</p></li>
                        </ul>
                    </ul>
                </div>
                <collapse-panel title="Publish an Observable">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent, Observable } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    class MyComponent extends HTMLElement {
                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { 
                                            const user = { 
                                                "user": {
                                                    "id": "123456789",
                                                    "name": "Joe Test",
                                                    "email": "joe.test@example.com",
                                                    "role": "admin",
                                                    "createdAt": "2025-07-24T10:00:00Z"
                                                }, 
                                                token: "12345abcdeTOKENxyz789" 
                                            };
                                            observable.publish('user-logged-in', user);
                                        }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Document Content -->
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Source Code -->
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <collapse-panel title="Subscribe to an Observable">
                    <template>
                        <tab-panel tabs="${this.tabNames}">
                            <template>
                                <code-viewer data-tab-id="Javascript" class="tabcontent" language="javascript" theme="tomorrow-night-blue">
                                    import { HTMLComponent, Observable } from '@modular-cube';
                                    import config from './MyComponent.config.json' with { type: "json" };

                                    class MyComponent extends HTMLElement {
                                        preProcess() {
                                            super.preProcess({ config });
                                        }

                                        atProcess(dom) { 
                                            observable.subscribe('user-logged-in', (user) => {
                                                console.log(user); 
                                                /* console output: 
                                                    {
                                                        "user": {
                                                            "id": "123456789",
                                                            "name": "Joe Test",
                                                            "email": "joe.test@example.com",
                                                            "role": "admin",
                                                            "createdAt": "2025-07-24T10:00:00Z"
                                                        }, 
                                                        token: "12345abcdeTOKENxyz789"
                                                    }
                                                */
                                            });
                                        }

                                        inProcess(dom) { }
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="HTML-Markup" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Document Content -->
                                </code-viewer>
                                <code-viewer data-tab-id="CSS-Styles" class="tabcontent" language="css" theme="tomorrow-night-blue">
                                    /* Styling for UI Components */
                                    :host {
                                        width: 100%;
                                        height: 100%;
                                    }
                                </code-viewer>
                                <code-viewer data-tab-id="Preview-Source-Code" class="tabcontent" language="xml" theme="tomorrow-night-blue">
                                    <!-- Source Code -->
                                </code-viewer>
                            </template>
                        </tab-panel>
                    </template>
                </collapse-panel>
                <div class="note-card">
                    <h3>💡 Notes</h3>
                    <ul> 
                        <li>Component A notifies Component B to refresh data.</li> 
                        <li>This is a global system, use unique event names to avoid collisions.</li> 
                    </ul>
                </div>
                <p>
                    The <span class="highlight">Observable</span> system can be used for reactive data handling, custom event broadcasting, or integrating cross-component behaviors in a clean, manageable way.
                </p>

                <!-- TODO -->
                <!-- Update -->
                <!-- <h3 id="update">Update</h3> -->
                <!--  -->
            </section>
        </section>
        <!-- Community & Support -->
        <section>
            <h3 id="community-and-support">Community & Support 💬</h3>
            <section class="sub-section">
                <!-- Changelog -->
                <h3 id="changelog">Changelog</h3>
                <div>
                    <h3><span class="date">Year 2025</span></h3>
                    <ul class="log-group added">
                        <li><strong>Added:</strong></li>
                        <li>Initial beta release of framework.</li>
                        <li>Base <code>HTMLComponent</code> class with Shadow DOM support.</li>
                        <li>Structured 4-file component convention (.js, .html, .css, .config.json).</li>
                        <li>Lifecycle flow: <code>preProcess()</code> → <code>toProcess()</code> → <code>atProcess()</code> → <code>inProcess()</code>.</li>
                        <li>Support for <code>lazyLoading</code>.</li>
                        <li>Component registry via <code>app.config.json</code>.</li>
                        <li>Global <code>Dom.init()</code> for unified initialization.</li>
                        <li>Template interpolation directly within HTML content and CSS</code>.</li>
                        <li><code>if</code>, <code>else if</code>, <code>else</code> and <code>forEach</code> directive availaible in the HTML template.</code>.</li>
                    </ul>
                    <ul class="log-group changed">
                        <li><strong>Work in progress:</strong></li>
                        <li><span class="highlight">Targeted Updates</span>: scoped and localized update for DOM elements.</li>
                        <li>Support for <code>apendToBody</code>.</li>
                    </ul>
                    <ul class="log-group fixed">
                        <li><strong>Next to come:</strong></li>
                        <li><span class="highlight">Reactive Data Binding</span>: core mechanism that updates the DOM when data changes.</code>.</li>
                    </ul>
                </div>
            </section>
        </section>
    </div>

    <!-- Ads -->
    <div id="ads">
        <div class="ads-container">
            <div class="section-notice">
                <div class="notice-icon">🚧 Under Construction</div>
                <div class="notice-text">Content for this section will be available soon.</div>
            </div>
        </div>
    </div>
</manual>

<!-- Disclaimer -->
<disclaimer> Site design / logo © 2025 MMXXII Ltd. - All Rights Reserved </disclaimer>